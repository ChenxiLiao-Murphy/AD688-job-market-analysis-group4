{
  "hash": "10b902cf78206c166f99bd578e0ea3e6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Modeling & Analysis\"\nformat:\n  html:\n    toc: true\n    code-fold: true\nbibliography: references.bib\ncsl: csl/econometrica.csl\nexecute:\n    echo: true\n    eval: false\n    freeze: auto\n---\n\n# Introduction\n\nThis section presents our machine learning models to analyze geographic and remote work patterns in the 2024 U.S. job market. We apply both **unsupervised** and **supervised** learning methods to gain insights into how job locations and remote types impact salaries and job classifications.\n\n---\n\n# 1. Unsupervised Learning: KMeans Clustering\n\nWe applied KMeans clustering on job postings using `STATE_NAME`, `REMOTE_TYPE_NAME`, and `SOC_2021_4` to group jobs by remote type and geographic similarities.\n\n::: {#6295d4a5 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\ndf = pd.read_csv(\"data/lightcast_job_postings.csv\")\nprint(df.columns.tolist())\n```\n:::\n\n\n::: {#2f36c48e .cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.cluster import KMeans\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.decomposition import PCA\n\n# STEP 1: Load your cleaned dataset\ndf = pd.read_csv(\"data/lightcast_job_postings.csv\") \n\n# STEP 2: Select columns\ncols = ['STATE_NAME', 'REMOTE_TYPE_NAME', 'SOC_2021_4']\ndf_cluster = df[cols].dropna()\ndf_cluster_encoded = pd.get_dummies(df_cluster)\n\n# STEP 3: Scale and cluster\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(df_cluster_encoded)\n\nkmeans = KMeans(n_clusters=4, random_state=42)\nclusters = kmeans.fit_predict(X_scaled)\ndf_cluster['Cluster'] = clusters\n\n# STEP 4: Visualize with PCA\npca = PCA(n_components=2)\ncomponents = pca.fit_transform(X_scaled)\n\nplt.figure(figsize=(8,6))\nplt.scatter(components[:, 0], components[:, 1], c=clusters, cmap='Set2')\nplt.title(\"KMeans Clusters by Location and Remote Type\")\nplt.xlabel(\"PCA Component 1\")\nplt.ylabel(\"PCA Component 2\")\n\n# save the figure\nplt.tight_layout()\nplt.savefig(\"figuresmurphy/kmeans_location_remote_pca.png\", dpi=300)\n\nplt.show()\n```\n:::\n\n\n![](figuresmurphy/kmeans_location_remote_pca.png){width=80% fig-align='center' fig-cap=\"KMeans Clusters by Location and Remote Type\"}\n\n\n## 2. Supervised Learning: Classification – Predict Remote Type\n\nWe trained a Random Forest Classifier to predict `REMOTE_TYPE_NAME` based on job location (`STATE_NAME`), job category (`SOC_2021_4`), and experience (`MAX_YEARS_EXPERIENCE`). The model helps identify which job characteristics are more likely to be remote, hybrid, or onsite.\n\n::: {#d2eb3a59 .cell execution_count=3}\n``` {.python .cell-code}\n# Import libraries\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import classification_report, confusion_matrix\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Prepare dataset\ndf_class = df[['STATE_NAME', 'SOC_2021_4', 'MAX_YEARS_EXPERIENCE', 'REMOTE_TYPE_NAME']].dropna()\ndf_class_encoded = pd.get_dummies(df_class, columns=['STATE_NAME', 'SOC_2021_4'])\n\nX = df_class_encoded.drop('REMOTE_TYPE_NAME', axis=1)\ny = df_class['REMOTE_TYPE_NAME']\n\n# Train/test split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n\n# Train classifier\nclf = RandomForestClassifier(random_state=42)\nclf.fit(X_train, y_train)\ny_pred = clf.predict(X_test)\n\n# Print performance\nprint(classification_report(y_test, y_pred))\nprint(confusion_matrix(y_test, y_pred))\n\n\n# Visualize confusion matrix\nplt.figure(figsize=(6,5))\nsns.heatmap(confusion_matrix(y_test, y_pred), annot=True, fmt='d', cmap='Blues')\nplt.title(\"Confusion Matrix - Remote Work Type Classifier\")\nplt.xlabel(\"Predicted\")\nplt.ylabel(\"Actual\")\nplt.tight_layout()\n\n# Save\nplt.savefig(\"figuresmurphy/confusion_matrix_remote_type.png\", dpi=300)\nplt.show()\n```\n:::\n\n\n![](figuresmurphy/confusion_matrix_remote_type.png){width=70% fig-align='center' fig-cap=\"Confusion Matrix of Random Forest Classifier for Remote Work Type\"}\n\n## 3. Supervised Learning: Regression – Predict Salary\n\nWe trained a Random Forest Regressor to predict `AVERAGE_SALARY` based on job attributes such as `STATE_NAME`, `REMOTE_TYPE_NAME`, `SOC_2021_4`, and `MAX_YEARS_EXPERIENCE`.\n\n::: {#74a9ee49 .cell execution_count=4}\n``` {.python .cell-code}\n# Step 1: Create AVERAGE_SALARY if not already in df\ndf['SALARY_FROM'] = pd.to_numeric(df['SALARY_FROM'], errors='coerce')\ndf['SALARY_TO'] = pd.to_numeric(df['SALARY_TO'], errors='coerce')\ndf['AVERAGE_SALARY'] = (df['SALARY_FROM'] + df['SALARY_TO']) / 2\n\n# Step 2: Drop rows with missing values in key columns\ndf_reg = df[['STATE_NAME', 'SOC_2021_4', 'REMOTE_TYPE_NAME', 'MAX_YEARS_EXPERIENCE', 'AVERAGE_SALARY']].dropna()\n\n# Step 3: One-hot encoding\ndf_reg_encoded = pd.get_dummies(df_reg, columns=['STATE_NAME', 'SOC_2021_4', 'REMOTE_TYPE_NAME'])\n\n# Step 4: Split X and y\nX = df_reg_encoded.drop('AVERAGE_SALARY', axis=1)\ny = df_reg_encoded['AVERAGE_SALARY']\n\n# Step 5: Train/test split\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n\n# Step 6: Train Random Forest Regressor\nfrom sklearn.ensemble import RandomForestRegressor\nmodel = RandomForestRegressor(random_state=42)\nmodel.fit(X_train, y_train)\n\n# Step 7: Predict\ny_pred = model.predict(X_test)\n\n# Step 8: Evaluate\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score\nprint(\"Mean Squared Error:\", mean_squared_error(y_test, y_pred))\nprint(\"Mean Absolute Error:\", mean_absolute_error(y_test, y_pred))\nprint(\"R2 Score:\", r2_score(y_test, y_pred))\n\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(6,6))\nplt.scatter(y_test, y_pred, alpha=0.5)\nplt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--')\nplt.xlabel(\"Actual Salary\")\nplt.ylabel(\"Predicted Salary\")\nplt.title(\"Actual vs Predicted Salary\")\nplt.tight_layout()\nplt.savefig(\"figuresmurphy/actual_vs_predicted_salary.png\", dpi=300)\nplt.show()\n```\n:::\n\n\n![](figuresmurphy/actual_vs_predicted_salary.png){width=70% fig-align='center' fig-cap=\"Actual vs. Predicted Salary by Random Forest\"}\n\n\n\n# Which states are more inclined to offer Remote/Hybrid/Onsite jobs?哪些州更倾向于提供远程/混合/现场工作？\n\n::: {#990827dc .cell execution_count=5}\n``` {.python .cell-code}\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndf_geo = df[['STATE_NAME', 'REMOTE_TYPE_NAME']].dropna()\n\n）\nstate_remote_counts = pd.crosstab(df_geo['STATE_NAME'], df_geo['REMOTE_TYPE_NAME'])\n\n# visualization\nstate_remote_counts.plot(kind='bar', stacked=True, figsize=(14,6))\nplt.title(\"Remote Work Type Distribution by State\")\nplt.xlabel(\"State\")\nplt.ylabel(\"Number of Job Postings\")\nplt.xticks(rotation=90)\nplt.tight_layout()\n\n\nplt.savefig(\"figuresmurphy/remote_type_by_state.png\", dpi=300)\nplt.show()\n```\n:::\n\n\n![Remote Work Type by State](figuresmurphy/remote_type_by_state.png){width=80% fig-align='center' fig-cap=\"Distribution of Remote Work Type Across States\"}\n\n\n# Which type of remote work offers a higher salary? 哪种远程类型的工资更高？\n\n::: {#3a01f64b .cell execution_count=6}\n``` {.python .cell-code}\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# deal with salary list\ndf_salary = df[['REMOTE_TYPE_NAME', 'SALARY']].dropna()\ndf_salary = df_salary[df_salary['SALARY'] < 300000]  # 过滤异常值（可选）\n\n\nplt.figure(figsize=(8,6))\nsns.boxplot(data=df_salary, x='REMOTE_TYPE_NAME', y='SALARY')\nplt.title(\"Salary Distribution by Remote Work Type\")\nplt.xlabel(\"Remote Work Type\")\nplt.ylabel(\"Salary\")\nplt.tight_layout()\n\nplt.savefig(\"figuresmurphy/salary_by_remote_type.png\", dpi=300)\nplt.show()\n```\n:::\n\n\n![Salary by Remote Type](figuresmurphy/salary_by_remote_type.png){width=70% fig-align='center' fig-cap=\"Boxplot of Salary Distribution Across Remote Work Types\"}\n\n::: {#df7eeac4 .cell execution_count=7}\n``` {.python .cell-code}\nremote_ratio_by_state.sort_values('REMOTE_RATIO', ascending=False).head(10)\n```\n:::\n\n\n# map\n\n::: {#f7713f49 .cell execution_count=8}\n``` {.python .cell-code}\nimport pandas as pd\nimport plotly.express as px\nimport pandas as pd\nimport plotly.express as px\n\n# 1. Create a full name -> abbreviation mapping table\nstate_abbrev_map = {\n    'Alabama': 'AL', 'Alaska': 'AK', 'Arizona': 'AZ', 'Arkansas': 'AR', 'California': 'CA',\n    'Colorado': 'CO', 'Connecticut': 'CT', 'Delaware': 'DE', 'Florida': 'FL', 'Georgia': 'GA',\n    'Hawaii': 'HI', 'Idaho': 'ID', 'Illinois': 'IL', 'Indiana': 'IN', 'Iowa': 'IA',\n    'Kansas': 'KS', 'Kentucky': 'KY', 'Louisiana': 'LA', 'Maine': 'ME', 'Maryland': 'MD',\n    'Massachusetts': 'MA', 'Michigan': 'MI', 'Minnesota': 'MN', 'Mississippi': 'MS',\n    'Missouri': 'MO', 'Montana': 'MT', 'Nebraska': 'NE', 'Nevada': 'NV', 'New Hampshire': 'NH',\n    'New Jersey': 'NJ', 'New Mexico': 'NM', 'New York': 'NY', 'North Carolina': 'NC',\n    'North Dakota': 'ND', 'Ohio': 'OH', 'Oklahoma': 'OK', 'Oregon': 'OR', 'Pennsylvania': 'PA',\n    'Rhode Island': 'RI', 'South Carolina': 'SC', 'South Dakota': 'SD', 'Tennessee': 'TN',\n    'Texas': 'TX', 'Utah': 'UT', 'Vermont': 'VT', 'Virginia': 'VA', 'Washington': 'WA',\n    'West Virginia': 'WV', 'Wisconsin': 'WI', 'Wyoming': 'WY'\n}\n\n# 2. Add a column of state abbreviations\nremote_ratio_by_state['STATE_ABBR'] = remote_ratio_by_state['STATE_NAME'].map(state_abbrev_map)\n\nprint(remote_ratio_by_state[['STATE_NAME', 'STATE_ABBR']].head())\n\nfig = px.choropleth(\n    remote_ratio_by_state,\n    locations='STATE_ABBR',\n    locationmode='USA-states',\n    color='REMOTE_RATIO',\n    scope='usa',\n    color_continuous_scale='Blues',\n    title='Proportion of Remote Jobs by State (Using State Abbreviations)',\n    width=1000,      \n    height=600       \n)\n\nfig.show()\n```\n:::\n\n\n# need help with can't save it!!!\n\n\n\n# logistic Regression\n\n::: {#beea49f0 .cell execution_count=9}\n``` {.python .cell-code}\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import classification_report, confusion_matrix\n\n# 1. 预处理 Preprocessing\ndf_logistic = df[['STATE_NAME', 'MAX_YEARS_EXPERIENCE', 'AVERAGE_SALARY', 'REMOTE_TYPE_NAME']].dropna()\n\ndf_logistic['REMOTE_TYPE_CLEANED'] = df_logistic['REMOTE_TYPE_NAME'].map({\n    'Remote': 'Remote',\n    'Hybrid Remote': 'Hybrid',\n    'Not Remote': 'Onsite'\n}).fillna('Onsite')\n\n# 创建二元分类标签列 Create binary classification target\ndf_logistic['IS_REMOTE'] = df_logistic['REMOTE_TYPE_CLEANED'].apply(lambda x: 1 if x == 'Remote' else 0)\n\n# 2. One-hot 编码州名 One-hot encode state name\ndf_encoded = pd.get_dummies(df_logistic, columns=['STATE_NAME'], drop_first=True)\n\n# 3. 拆分数据 Split data\nX = df_encoded.drop(['IS_REMOTE', 'REMOTE_TYPE_NAME', 'REMOTE_TYPE_CLEANED'], axis=1)\ny = df_encoded['IS_REMOTE']\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n\n# 4. 训练模型 Train model\nmodel = LogisticRegression(max_iter=1000)\nmodel.fit(X_train, y_train)\ny_pred = model.predict(X_test)\n\n# 5. 模型评估 Evaluation\nprint(\"Confusion Matrix:\\n\", confusion_matrix(y_test, y_pred))\nprint(\"\\nClassification Report:\\n\", classification_report(y_test, y_pred))\n\n# 6. 可视化混淆矩阵 Visualize confusion matrix\nplt.figure(figsize=(6,4))\nsns.heatmap(confusion_matrix(y_test, y_pred), annot=True, fmt='d', cmap='Blues')\nplt.title(\"Confusion Matrix 热力图\")\nplt.xlabel(\"预测值 Predicted\")\nplt.ylabel(\"实际值 Actual\")\nplt.tight_layout()\nplt.savefig(\"figuresmurphy/logistic_confusion_matrix.png\", dpi=300)\nplt.show()\n```\n:::\n\n\n# Linear Regression\n\n::: {#28a4ae25 .cell execution_count=10}\n``` {.python .cell-code}\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error, r2_score\nimport matplotlib.pyplot as plt\n\n# 1. 预处理 Preprocessing\ndf_reg = df[['STATE_NAME', 'MAX_YEARS_EXPERIENCE', 'REMOTE_TYPE_NAME', 'AVERAGE_SALARY']].dropna()\ndf_reg = df_reg[df_reg['AVERAGE_SALARY'] < 300000]  # 去除极端值 Remove salary outliers\n\ndf_reg['REMOTE_TYPE_CLEANED'] = df_reg['REMOTE_TYPE_NAME'].map({\n    'Remote': 'Remote',\n    'Hybrid Remote': 'Hybrid',\n    'Not Remote': 'Onsite'\n}).fillna('Onsite')\n\n# 2. One-hot 编码 One-hot encode\ndf_reg_encoded = pd.get_dummies(df_reg, columns=['STATE_NAME', 'REMOTE_TYPE_CLEANED'], drop_first=True)\n\n# 3. 拆分数据 Split data\nX = df_reg_encoded.drop(['REMOTE_TYPE_NAME', 'AVERAGE_SALARY'], axis=1)\ny = df_reg_encoded['AVERAGE_SALARY']\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n\n# 4. 建模 Train model\nreg_model = LinearRegression()\nreg_model.fit(X_train, y_train)\ny_pred = reg_model.predict(X_test)\n\n# 5. 评估 Evaluation\nprint(\"MSE:\", mean_squared_error(y_test, y_pred))\nprint(\"R-squared:\", r2_score(y_test, y_pred))\n\n# 6. 可视化 - 实际 vs 预测工资散点图 Scatterplot of actual vs predicted\nplt.figure(figsize=(6, 5))\nplt.scatter(y_test, y_pred, alpha=0.5)\nplt.xlabel(\"实际工资 Actual Salary\")\nplt.ylabel(\"预测工资 Predicted Salary\")\nplt.title(\"实际 vs 预测工资散点图 (Actual vs. Predicted Salary)\")\nplt.tight_layout()\nplt.savefig(\"figuresmurphy/regression_actual_vs_predicted.png\", dpi=300)\nplt.show()\n\n# 7. 可视化 - 残差分布图 Residuals histogram\nresiduals = y_test - y_pred\nplt.figure(figsize=(6, 4))\nplt.hist(residuals, bins=30, color='orange', edgecolor='black')\nplt.title(\"残差分布图 Residuals Histogram\")\nplt.xlabel(\"残差 Residuals\")\nplt.ylabel(\"频率 Frequency\")\nplt.tight_layout()\nplt.savefig(\"figuresmurphy/regression_residuals.png\", dpi=300)\nplt.show()\n```\n:::\n\n\n",
    "supporting": [
      "modeling_analysis_files"
    ],
    "filters": [],
    "includes": {}
  }
}